{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/JS정리/",
    "result": {"data":{"site":{"siteMetadata":{"title":"블로그"}},"markdownRemark":{"id":"7bb7d3f7-47d8-5e58-b1a9-0fc1278033da","excerpt":"원시 값과 전역객체와 전역프로퍼티 전역객체 브라우저에서 자바스크립트의 전역객체는 window이다. 전역이라 여겨지는 객체와 함수는 window객체의 프로퍼티\n자바스크립트의 객체는 프로퍼티를 갖는다. 전역프로퍼티 window의 프로퍼티 중 Infinity, NaN, undefined…","html":"<h1>원시 값과 전역객체와 전역프로퍼티</h1>\n<h2>전역객체</h2>\n<p>브라우저에서 자바스크립트의 전역객체는 window이다. 전역이라 여겨지는 객체와 함수는 window객체의 프로퍼티\n자바스크립트의 객체는 프로퍼티를 갖는다.</p>\n<h2>전역프로퍼티</h2>\n<p>window의 프로퍼티 중 Infinity, NaN, undefined이 있는데\nInfinity는 어떤 숫자보다 큰 값이고, NaN는 숫자가 아님을, undefined는 원시 값 undefined를 가진다.</p>\n<h3>메서드</h3>\n<p>window의 메서드를 전역함수라고 부른다. 다음과 같은 메서드들이 있다.</p>\n<ul>\n<li>eval() code를 문자열로 전달하면 그 코드를 실행하고 표현식을 전달하면 표현식을 출력한다.</li>\n<li>isFinite() 인자로 전달한 것이 유한하면 참 아니면 거짓을 리턴한다.</li>\n<li>isNaN() 인자로 전달한 것이 숫자면 거짓 아니면 참을 리턴한다.</li>\n<li>parseFloat() 문자열을 전달하면 부동소수점수로 바꿔서 반환한다.</li>\n<li>parseInt() 문자열을 전달하면 정수로 바꿔서 반환한다.</li>\n<li>encodeURI() / decodeURI() 문자열을 이스케이프처리 / 복원한다.</li>\n<li>encodeURIComponent() / decodeURIComponent() =?&#x26;도 이스케이프 처리/복원한다.</li>\n</ul>\n<h2>원시 값</h2>\n<p>원시값은 값이며 변수가 아니다. 불변데이터로 각자가 각자만의 의미를 가진다. 예를들어 32는 원시값으로\n원시값 32는 32라는 의미를 갖는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var a = 32;\na += 1 // 여기서는 a라는 변수의 원시값이 33이 된 것으로\n       // 32라는 원시값이 33이 된것이 아니다.</code></pre></div>\n<ul>\n<li>원시 값에는 아래와 같은 타입이 있다.\n<ul>\n<li>Boolean 타입</li>\n<li>Null 타입</li>\n<li>Undefined 타입</li>\n<li>Number 타입</li>\n<li>BigInt 타입</li>\n<li>String 타입</li>\n<li>Symbol 타입</li>\n</ul>\n</li>\n</ul>\n<h1>호스트 객체와 네이티브객체</h1>\n<h2>네이티브 객체</h2>\n<p>ECMAScript에서는 아래와 같은 네이티브 객체를 정의하고 있다.</p>\n<ul>\n<li>Object</li>\n<li>Number</li>\n<li>Math</li>\n<li>Date</li>\n<li>Array</li>\n<li>String</li>\n<li>RegExp</li>\n</ul>\n<h3>자바스크립트의 array의 특징</h3>\n<ul>\n<li>array는 다른 언어의 배열과는 다르게 배열 요소들의 타입이 서로 달라도 무방하다.</li>\n<li>그리고 배열 요소들이 메모리에서 연속적으로 이어져 있지 않다.</li>\n<li>이는 일반적인 배열 자료구조와는 다르며 인덱스( 0, 1, 12 등)을 프로퍼티 이름으로 갖고 있는 객체라고 보는게 더 적절하다.</li>\n</ul>\n<h2>호스트 객체</h2>\n<p>네이티브 객체가 아니면 모두 호스트 객체이다.</p>\n<ul>\n<li>DOM : document, HTMLElement 등</li>\n<li>XMLHttpRequest</li>\n<li>location : 주소창 관련</li>\n<li>history : 히스토리 관련</li>\n<li>navigator 브라우저 상태나 관련 정보들</li>\n<li>screen : 화면 크기 등 화면 정보 제공</li>\n</ul>\n<h1>자바스크립트의 함수</h1>\n<h2>다른언어와의 차이점</h2>\n<p>자바스크립트의 함수와 다른 언어와의 차이점은 함수를 데이터로 바라본다는 것이다.\n다시 말해 자바스크립트에서 함수는 일급객체이다.</p>\n<h2>Call-by-value / Call-by-reference</h2>\n<p>자바스크립트에서 원시값을 인자로 전달하면 Call-by-value(값을 복사해서 전달한다.)</p>\n<p>객체를 인자로 전달하면 Call-by-reference(참조 값을 전달한다.)로 전달된다.</p>\n<p>Call-by-reference로 전달 시 객체 자체를 변경할 수 있다는 점을 주의할 것</p>\n<h2>선언방법</h2>\n<ol>\n<li>function f(){}</li>\n<li>var f = function(){}</li>\n<li>new Function(arg1, arg2,arg3, … , ‘함수몸체, 중괄호로 감싸는부분’)</li>\n</ol>\n<h2>즉시실행함수</h2>\n<p>주로 라이브러리에서 충돌을 방지하고 글로벌 스코프를 깨끗하게 유지하는데 사용한다. 혹은 초기화 코드를 실행할때\n단 한번만 실행되도록 하기 위해서 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(function () {\n  // ...\n}());\n//위와 같이 사용한다.</code></pre></div>\n<h2>this와 apply/call/bind</h2>\n<p>this는 호출대상을 의미한다. 매서드의 this는 해당 매서드를 가진 객체가 된다.</p>\n<h3>주의할점</h3>\n<ul>\n<li>내부함수에서는 그 함수를 실행하는 대상이 전역객체이기 때문에 전역객체가 this가 된다. 콜백함수 역시 마친가지다.</li>\n</ul>\n<p>this를 변경하고 싶다면 apply, call, bind등의 함수를 사용한다.</p>\n<ul>\n<li>apply call\n함수의 기본 메서드로 첫번째 인자로 전달하는 객체를 해당 함수의 this로 하여 실행시킨다.\n<ul>\n<li>f.apply(bar, [인수 배열]) f.call(bar, 인수1, 인수2, 인수3…);</li>\n</ul>\n</li>\n<li>bind\nvar f1 = f.bind(a); this를 a로 바인드시킨 함수를 반환한다.</li>\n</ul>\n<h1>실행 컨텍스트와 스코프 그리고 클로저</h1>\n<p>실행컨텍스트는 일종의 코드실행환경으로 코드를 실행하는데 필요한 데이터(변수, 함수, 객체)를 담는다.</p>\n<p>실행 컨텍스트가 생성되고 파괴되는 흐름은 다음과 같다.</p>\n<ol>\n<li>함수를 실행하면 새로운 실행 컨텍스트가 생성되고 이것이 실행 컨텍스트 스택에 쌓인다.</li>\n<li>현재 실행중인 코드는 스택의 제일 위에있는 실행 컨텍스트에서 정보를 찾게 된다.</li>\n<li>함수가 종료되면 스택에서 실행컨텍스트를 pop한다.</li>\n</ol>\n<h2>실행컨텍스트가 가지는 3가지 객체</h2>\n<ol>\n<li>Variable object : 현재 컨텍스트의 변수를 담은 activation object(AO)를 가리킨다.</li>\n<li>Scope chain : 현재 AO, 스택 아래쪽의 실행컨텍스트의 AO, … ,전역 컨텍스트의 GO를 가리키는 포인터리스트</li>\n<li>this : 는 this</li>\n</ol>\n<h2>스코프</h2>\n<p>자바스크립트에서 찾고자 하는 것이 현재 스코프에 없다면 스코프체인의 다음 스코프에서 찾고 이를 반복한다.\n함수마다 <code class=\"language-text\">[[Scopes]]</code> 프로퍼티가 있는데 내부에 선언된 함수라면 자신을 선언한 함수의 스코프도 볼 수 있다.\n이를 이용해서 클로저를 구현한다.</p>\n<p>?의문사항 실행컨텍스트의 스코프와 <code class=\"language-text\">[[scopes]]</code>가 다르다면 무엇이 우선으로 적용되는가? 아마 함수가 먼저일듯\n?클로저의 내부구현은 어떨까?</p>\n<h3>랙시컬 스코프</h3>\n<p>함수를 기준으로 스코프를 판단한다. 실행하는 곳이 아니라 선언된 곳 기준이라는 것을 주의할 것</p>\n<h3>블록 스코프 (es5아님)</h3>\n<p>{}으로 감싸고 let 과 const를 사용한다면 블록스코프에서 찾는다.</p>\n<h2>클로저</h2>\n<p>내부함수가 외부함수의 스코프에 접근 할 수 있는 것을 이용\n외부함수의 실행 컨텍스트가 이미 pop되었더라도 내부함수가 외부함수의 스코프의 데이터를 사용하게 하는 기법.\n접근방법을 제한하는 효과를 얻는다.</p>\n<h3>클로저활용방법</h3>\n<ol>\n<li>상태를 저장하고 갱신함 - 특정 상태값을 여러곳에서 접근가능하다면 관리가 힘들어지기 때문에 제한하는데 사용</li>\n<li>private 모방</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function outerFunc() {\n  var x = 10;\n  var innerFunc = function () { console.log(x); };\n  return innerFunc;\n}\nvar f = outerFunc();\nf();//x에 접근 할수 있고 10이 출력된다.</code></pre></div>\n<h2>호이스팅</h2>\n<p>함수 호이스팅 변수 호이스팅 등 차별하여 생각하기보다는 실행되기 전에 미리 사용할 데이터(함수,변수)를 메모리에 할당시키게 되고\n그렇기 때문에 코드에서 선언되기 전에 접근 할 수 있다고 생각하는게 쉽다.</p>\n<p>다만 주의할 점은 함수 선언방법에 따라 호이스팅이 다르게 동작하는것처럼 보이는데, 함수표현식을 사용했다면\n해당 라인이 실행되기 전이라 메모리에 공간은 만들어뒀지만 아직 변수에 함수를 저장되어 있지 않은 것으로 생각하면 된다.</p>\n<h1>객체와 프로토타입</h1>\n<p>모든 객체는 부모객체와 프로토타입으로 연결되어 있다. 모든 객체는 프로토타입으로 조상객체의 프로퍼티에 접근 할 수 있다.\n이를 이용해서 자바스크립트에서 상속을 구현 할 수 있다.</p>\n<p>자바스크립트에서는 객체를 new 연산자로 객체를 생성하거나\nnew Object();(혹은 {})로 빈객체를 만든 후 프로퍼티와 메소드 그리고 프로토타입을 추가하는 것을 통해 객체를 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var arr = [];\nvar obj = {};\nobj.__proto__ = arr.__proto__\nobj.length //이제 obj는 array 객체이다.</code></pre></div>\n<h2>생성자</h2>\n<p>모든 함수는 생성자가 될 수 있다. 대신 new 연산자를 사용해야한다.\n함수에서 this에 바인딩 한 변수는 생성된 객체의 프로퍼티가 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\n\nconst car1 = new Car('Eagle', 'Talon TSi', 1993);</code></pre></div>\n<p>모든 프로토타입 객체는 constructor 프로퍼티를 갖는다. 그리고 constructor 프로퍼티는 자신을 생성한 생성자를 가리킨다. 다시 말해 자신을 생성한 함수를 가리킨다.</p>\n<h2><strong>proto</strong>, <code class=\"language-text\">[[prototype]]</code>, prototype 프로퍼티</h2>\n<ol>\n<li><strong>proto</strong>는 <code class=\"language-text\">[[prototype]]</code>을 가리키는 포인터이다.</li>\n<li>prototype 프로퍼티는 함수객체가 생성자로 사용 될 때, 그 생성자가 생성하는 객체의 프로토타입 객체를 가리킨다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function a(){}\nvar aa = new a();\naa.__proto__ === a.prototype //true 이다.</code></pre></div>\n<h2>ES5 상속</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">__proto__를 통한 상속\nfunction Circle() {}\nconst shape = {}\nconst circle = new Circle()\n\n// Set the object prototype\n// DEPRECATED. 예시용일 뿐입니다. 실제 코드에서는 이렇게 하지 마세요.\nshape.__proto__ = circle</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//ES5 상속\nvar Student = function(name) {\n  Human.apply(this, [name]);\n}\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n//사람과 생성자가 같으면 안되니까 학생을 생성자로 넣어준다\nStudent.prototype.study = function () {\n  console.log(\"hi\");\n};\nvar stu = new Student('kim');</code></pre></div>\n<h1>브라우저의 랜더링 과정</h1>\n<ol>\n<li>html, css, javascript 등 파싱 대상이 되는 자원들은 브라우저의 파서가 파싱한다.</li>\n<li>HTML를 파싱하여 DOM tree를 얻고 CSS를 파싱하여 스타일 규칙을 얻는다.</li>\n<li>DOM tree의 노드와 그에 대응되는 각각의 스타일 정보를 합쳐 레이아웃 트리를 구성한다.</li>\n<li>레이아웃 트리 를 보고 페인트 트리를 구성한다.(z-order, 자식요소 등을 고려해 그려야할 순서를 판단)</li>\n<li>각 paint operation을 수행하면서 layer생성조건이 부합되면 새로운 layer를 만들어낸다.</li>\n<li>각 layer들은 레스터화(픽셀단위로 이미지화) 되어있고, 화면을 움직이면 브라우저는 그에 맞춰 레이어를 움직여가면서 새로운 화면을 그린다.</li>\n</ol>","frontmatter":{"title":"JS 정리","date":"May 21, 2022","description":"자바스크립트의 함수와 다른 언어와의 차이점은 함수를 데이터로 바라본다는 것이다. 다시 말해 자바스크립트에서 함수는 일급객체이다.","tag":"Web"}},"previous":{"fields":{"slug":"/배워볼래2/"},"frontmatter":{"title":"Test"}},"next":{"fields":{"slug":"/HTML정리/"},"frontmatter":{"title":"HTML 정리"}}},"pageContext":{"id":"7bb7d3f7-47d8-5e58-b1a9-0fc1278033da","previousPostId":"9d6fd6d7-316f-5407-b795-e71e35c4abc9","nextPostId":"385ab50a-d623-5b34-aff3-a89aad50d9cb"}},
    "staticQueryHashes": ["2841359383","3257411868"]}